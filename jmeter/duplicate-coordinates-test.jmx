<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Duplicate Coordinates Test" enabled="true">
      <stringProp name="TestPlan.comments">Тест одновременного импорта файлов с одинаковыми координатами (5 пользователей, первый должен пройти, остальные упасть)</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="SERVER_HOST" elementType="Argument">
            <stringProp name="Argument.name">SERVER_HOST</stringProp>
            <stringProp name="Argument.value">localhost</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SERVER_PORT" elementType="Argument">
            <stringProp name="Argument.name">SERVER_PORT</stringProp>
            <stringProp name="Argument.value">24180</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="API_PATH" elementType="Argument">
            <stringProp name="Argument.name">API_PATH</stringProp>
            <stringProp name="Argument.value">/human-being-manager/api/import/humanbeings/file</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - Parallel Import with Same Coordinates" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControllerGui" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <intProp name="LoopController.loops">1</intProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">5</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding">UTF-8</stringProp>
          <stringProp name="filename">test_files.csv</stringProp>
          <boolProp name="ignoreFirstLine">false</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <stringProp name="shareMode">shareMode.thread</stringProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="variableNames">testFile</stringProp>
        </CSVDataSet>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Import HumanBeings File with Duplicate Coordinates" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
            <stringProp name="script">import java.net.HttpURLConnection
import java.net.URL
import java.io.File
import java.io.FileInputStream
import java.io.OutputStream
import java.io.BufferedReader
import java.io.InputStreamReader
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder

String serverHost = props.get(&quot;SERVER_HOST&quot;) ?: &quot;localhost&quot;
String serverPort = props.get(&quot;SERVER_PORT&quot;) ?: &quot;24180&quot;
String apiPath = props.get(&quot;API_PATH&quot;) ?: &quot;/human-being-manager/api/import/humanbeings/file&quot;
String filePath = vars.get(&quot;testFile&quot;)

String url = &quot;http://&quot; + serverHost + &quot;:&quot; + serverPort + apiPath

File file = new File(filePath)
if (!file.exists()) {
    log.error(&quot;File not found: &quot; + filePath)
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(&quot;File not found: &quot; + filePath)
    return
}

// Read JSON file
String fileContent = new File(filePath).text
def jsonSlurper = new JsonSlurper()
def data = jsonSlurper.parseText(fileContent)

// Generate coordinates ONCE per test run (shared across all threads)
// Use synchronized block to ensure only first thread generates coordinates
synchronized(this.getClass()) {
    // Check if coordinates are already generated for this test run
    String coord1X = props.get(&quot;DUPLICATE_COORD1_X&quot;)
    String coord1Y = props.get(&quot;DUPLICATE_COORD1_Y&quot;)
    String coord2X = props.get(&quot;DUPLICATE_COORD2_X&quot;)
    String coord2Y = props.get(&quot;DUPLICATE_COORD2_Y&quot;)
    
    if (coord1X == null || coord1Y == null || coord2X == null || coord2Y == null) {
        // Generate new coordinates for this test run
        Random random = new Random()
        long timestamp = System.currentTimeMillis()
        long nanoTime = System.nanoTime()
        
        // Generate first coordinate pair (x, y) for first entity
        // Ensure values are within -1000 to 1000 range and not zero
        int coord1XValue = random.nextInt(1998) - 999  // -999 to 998
        if (coord1XValue == 0) {
            coord1XValue = random.nextBoolean() ? 1 : -1
        }
        double coord1YValue = (random.nextDouble() * 1998.0) - 999.0  // -999.0 to 998.999...
        if (Math.abs(coord1YValue) &lt; 0.001) {
            coord1YValue = random.nextBoolean() ? 0.5 : -0.5
        }
        
        // Generate second coordinate pair (x, y) for second entity
        // Make sure it's different from first pair
        int coord2XValue = random.nextInt(1998) - 999
        if (coord2XValue == 0) {
            coord2XValue = random.nextBoolean() ? 1 : -1
        }
        // Ensure second X is different from first X
        while (coord2XValue == coord1XValue) {
            coord2XValue = random.nextInt(1998) - 999
            if (coord2XValue == 0) {
                coord2XValue = random.nextBoolean() ? 1 : -1
            }
        }
        
        double coord2YValue = (random.nextDouble() * 1998.0) - 999.0
        if (Math.abs(coord2YValue) &lt; 0.001) {
            coord2YValue = random.nextBoolean() ? 0.5 : -0.5
        }
        // Ensure second Y is different from first Y (with some tolerance)
        while (Math.abs(coord2YValue - coord1YValue) &lt; 0.1) {
            coord2YValue = (random.nextDouble() * 1998.0) - 999.0
            if (Math.abs(coord2YValue) &lt; 0.001) {
                coord2YValue = random.nextBoolean() ? 0.5 : -0.5
            }
        }
        
        // Store coordinates in properties (shared across all threads)
        props.put(&quot;DUPLICATE_COORD1_X&quot;, String.valueOf(coord1XValue))
        props.put(&quot;DUPLICATE_COORD1_Y&quot;, String.valueOf(coord1YValue))
        props.put(&quot;DUPLICATE_COORD2_X&quot;, String.valueOf(coord2XValue))
        props.put(&quot;DUPLICATE_COORD2_Y&quot;, String.valueOf(coord2YValue))
        
        log.info(&quot;Generated duplicate coordinates for test run: Entity1=(${coord1XValue}, ${coord1YValue}), Entity2=(${coord2XValue}, ${coord2YValue})&quot;)
    }
}

// Retrieve coordinates from properties (same for all threads)
String coord1X = props.get(&quot;DUPLICATE_COORD1_X&quot;)
String coord1Y = props.get(&quot;DUPLICATE_COORD1_Y&quot;)
String coord2X = props.get(&quot;DUPLICATE_COORD2_X&quot;)
String coord2Y = props.get(&quot;DUPLICATE_COORD2_Y&quot;)

// Apply the SAME coordinates to all entities in the file
if (data instanceof List) {
    data.eachWithIndex { item, index -&gt;
        if (item.coordinates) {
            if (index == 0) {
                // First entity gets first coordinate pair
                item.coordinates.x = Integer.parseInt(coord1X)
                item.coordinates.y = Double.parseDouble(coord1Y)
            } else if (index == 1) {
                // Second entity gets second coordinate pair
                item.coordinates.x = Integer.parseInt(coord2X)
                item.coordinates.y = Double.parseDouble(coord2Y)
            }
        }
    }
}

String modifiedJson = new JsonBuilder(data).toPrettyString()

String boundary = &quot;----WebKitFormBoundary&quot; + System.currentTimeMillis()
String CRLF = &quot;\r\n&quot;

try {
    URL urlObj = new URL(url)
    HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection()
    connection.setRequestMethod(&quot;POST&quot;)
    connection.setDoOutput(true)
    connection.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + boundary)
    
    OutputStream outputStream = connection.getOutputStream()
    
    // Write file part
    outputStream.write((&quot;--&quot; + boundary + CRLF).getBytes())
    outputStream.write((&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;&quot; + file.getName() + &quot;\&quot;&quot; + CRLF).getBytes())
    outputStream.write((&quot;Content-Type: application/json&quot; + CRLF + CRLF).getBytes())
    
    // Write modified JSON content
    outputStream.write(modifiedJson.getBytes(&quot;UTF-8&quot;))
    
    outputStream.write((CRLF + &quot;--&quot; + boundary + &quot;--&quot; + CRLF).getBytes())
    outputStream.flush()
    outputStream.close()
    
    int statusCode = connection.getResponseCode()
    String responseBody = &quot;&quot;
    
    if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) {
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))
        String line
        while ((line = reader.readLine()) != null) {
            responseBody += line + &quot;\n&quot;
        }
        reader.close()
    } else {
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()))
        String line
        while ((line = reader.readLine()) != null) {
            responseBody += line + &quot;\n&quot;
        }
        reader.close()
    }
    
    SampleResult.setResponseCode(String.valueOf(statusCode))
    SampleResult.setResponseData(responseBody, &quot;UTF-8&quot;)
    SampleResult.setSuccessful(statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300)
    SampleResult.setResponseMessage(connection.getResponseMessage() ?: &quot;&quot;)
    
    connection.disconnect()
} catch (Exception e) {
    log.error(&quot;Error sending request&quot;, e)
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(&quot;Error: &quot; + e.getMessage())
}</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree>
          <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
          <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>

