<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Distributed Transaction Test" enabled="true">
      <stringProp name="TestPlan.comments">Тест распределенных транзакций при параллельных запросах импорта</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="SERVER_HOST" elementType="Argument">
            <stringProp name="Argument.name">SERVER_HOST</stringProp>
            <stringProp name="Argument.value">localhost</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SERVER_PORT" elementType="Argument">
            <stringProp name="Argument.name">SERVER_PORT</stringProp>
            <stringProp name="Argument.value">24180</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="API_PATH" elementType="Argument">
            <stringProp name="Argument.name">API_PATH</stringProp>
            <stringProp name="Argument.value">/human-being-manager/api/import/humanbeings/file</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - Parallel Import" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControllerGui" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <intProp name="LoopController.loops">1</intProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">5</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding">UTF-8</stringProp>
          <stringProp name="filename">test_files.csv</stringProp>
          <boolProp name="ignoreFirstLine">false</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <stringProp name="shareMode">shareMode.thread</stringProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="variableNames">testFile</stringProp>
        </CSVDataSet>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Import HumanBeings File" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
            <stringProp name="script">import java.net.HttpURLConnection
import java.net.URL
import java.io.File
import java.io.FileInputStream
import java.io.OutputStream
import java.io.BufferedReader
import java.io.InputStreamReader
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder

String serverHost = props.get(&quot;SERVER_HOST&quot;) ?: &quot;localhost&quot;
String serverPort = props.get(&quot;SERVER_PORT&quot;) ?: &quot;24180&quot;
String apiPath = props.get(&quot;API_PATH&quot;) ?: &quot;/human-being-manager/api/import/humanbeings/file&quot;
String filePath = vars.get(&quot;testFile&quot;)

String url = &quot;http://&quot; + serverHost + &quot;:&quot; + serverPort + apiPath

File file = new File(filePath)
if (!file.exists()) {
    log.error(&quot;File not found: &quot; + filePath)
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(&quot;File not found: &quot; + filePath)
    return
}

// Read and modify JSON to make coordinates unique
String fileContent = new File(filePath).text
def jsonSlurper = new JsonSlurper()
def data = jsonSlurper.parseText(fileContent)

// Generate unique coordinates within -1000 to 1000 range
// Use thread number, timestamp, nanoseconds, index, and random for maximum uniqueness
int threadNum = ctx.getThreadNum()
long baseTimestamp = System.currentTimeMillis()
Random random = new Random()

// Modify coordinates to be unique (staying within -1000 to 1000 range, not zero)
if (data instanceof List) {
    data.eachWithIndex { item, index -&gt;
        if (item.coordinates) {
            // Generate unique values for each element separately
            long nanoTime = System.nanoTime()
            int randomValue = random.nextInt(10000)
            int randomOffsetX = random.nextInt(100) - 50  // Random offset between -50 and 50
            int randomOffsetY = random.nextInt(100) - 50
            
            // Create unique ID for this specific element combining all factors
            long elementUniqueId = (baseTimestamp + nanoTime + threadNum * 1000000000L + index * 100000L + randomValue) % 2000000L
            
            // Calculate unique coordinates using multiple factors:
            // - Thread number for base separation (each thread gets different range)
            // - Index for separation within file
            // - Unique ID for this element
            // - Random offsets for additional unpredictability
            // Thread 0: x=-900 to -100, Thread 1: x=-100 to 100, Thread 2: x=100 to 300, etc.
            int threadBaseX = -900 + (threadNum * 200)  // -900, -700, -500, -300, -100
            double threadBaseY = -800.5 + (threadNum * 200)  // -800.5, -600.5, -400.5, -200.5, -0.5
            
            // Calculate offsets with multiple uniqueness factors
            int indexOffset = index * 15  // More spacing between elements
            int uniqueOffsetX = (int)(elementUniqueId % 150)  // Use modulo for range control
            double uniqueOffsetY = (elementUniqueId % 150) + 0.5
            
            // Combine all offsets
            int totalOffsetX = indexOffset + uniqueOffsetX + randomOffsetX
            double totalOffsetY = indexOffset + uniqueOffsetY + randomOffsetY
            
            int baseX = threadBaseX + totalOffsetX
            double baseY = threadBaseY + totalOffsetY
            
            // Ensure within valid range and not zero
            while (baseX &gt;= 1000 || baseX &lt;= -1000 || baseX == 0) {
                if (baseX &gt;= 1000) {
                    baseX = 900 - (threadNum * 50) - (index * 20) - (int)(elementUniqueId % 30) - random.nextInt(20)
                } else if (baseX &lt;= -1000) {
                    baseX = -900 + (threadNum * 50) + (index * 20) + (int)(elementUniqueId % 30) + random.nextInt(20)
                } else if (baseX == 0) {
                    baseX = 1 + (threadNum * 10) + (index * 5) + (int)(elementUniqueId % 10) + random.nextInt(5)
                }
            }
            
            while (baseY &gt;= 1000 || baseY &lt;= -1000 || baseY == 0) {
                if (baseY &gt;= 1000) {
                    baseY = 900.0 - (threadNum * 50) - (index * 20) - (elementUniqueId % 30) - random.nextInt(20) - 0.5
                } else if (baseY &lt;= -1000) {
                    baseY = -900.0 + (threadNum * 50) + (index * 20) + (elementUniqueId % 30) + random.nextInt(20) + 0.5
                } else if (baseY == 0) {
                    baseY = 1.1 + (threadNum * 10) + (index * 5) + (elementUniqueId % 10) + random.nextInt(5)
                }
            }
            
            item.coordinates.x = baseX
            item.coordinates.y = baseY
        }
    }
}

String modifiedJson = new JsonBuilder(data).toPrettyString()

String boundary = &quot;----WebKitFormBoundary&quot; + System.currentTimeMillis()
String CRLF = &quot;\r\n&quot;

try {
    URL urlObj = new URL(url)
    HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection()
    connection.setRequestMethod(&quot;POST&quot;)
    connection.setDoOutput(true)
    connection.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + boundary)
    
    OutputStream outputStream = connection.getOutputStream()
    
    // Write file part
    outputStream.write((&quot;--&quot; + boundary + CRLF).getBytes())
    outputStream.write((&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;&quot; + file.getName() + &quot;\&quot;&quot; + CRLF).getBytes())
    outputStream.write((&quot;Content-Type: application/json&quot; + CRLF + CRLF).getBytes())
    
    // Write modified JSON content
    outputStream.write(modifiedJson.getBytes(&quot;UTF-8&quot;))
    
    outputStream.write((CRLF + &quot;--&quot; + boundary + &quot;--&quot; + CRLF).getBytes())
    outputStream.flush()
    outputStream.close()
    
    int statusCode = connection.getResponseCode()
    String responseBody = &quot;&quot;
    
    if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) {
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))
        String line
        while ((line = reader.readLine()) != null) {
            responseBody += line + &quot;\n&quot;
        }
        reader.close()
    } else {
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()))
        String line
        while ((line = reader.readLine()) != null) {
            responseBody += line + &quot;\n&quot;
        }
        reader.close()
    }
    
    SampleResult.setResponseCode(String.valueOf(statusCode))
    SampleResult.setResponseData(responseBody, &quot;UTF-8&quot;)
    SampleResult.setSuccessful(statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300)
    SampleResult.setResponseMessage(connection.getResponseMessage() ?: &quot;&quot;)
    
    connection.disconnect()
} catch (Exception e) {
    log.error(&quot;Error sending request&quot;, e)
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(&quot;Error: &quot; + e.getMessage())
}</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree>
          <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
          <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
